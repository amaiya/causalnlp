# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_learners.ipynb (unless otherwise specified).

__all__ = ['BaseTextLearner', 'DefaultTextLearner']

# Cell
from lightgbm import LGBMClassifier, LGBMRegressor

# Cell
import sklearn
from sklearn.datasets import load_files
from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer
from sklearn.feature_extraction.text import TfidfTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression, LinearRegression, SGDClassifier
from sklearn.datasets import load_files
from joblib import dump, load
import string
import numpy as np
from abc import ABC, abstractmethod


class BaseTextLearner(ABC):
    """
    Abstract class for text classifier/regressor for use with metalearners
    """

    @abstractmethod
    def fit(self, x_train, y_train):
        """
        Train a classifier.
        """
        pass

    @abstractmethod
    def predict(self, x_test, return_proba=False):
        """
        Make predictions on text data.
        """
        pass

    @abstractmethod
    def predict_proba(self, x_test):
        """
        predict_proba returns the prediction probabilities for texts in  `x_test`
        """
        pass



class DefaultTextLearner(BaseTextLearner):
    def __init__(self, is_classifier=True, model=None):
        """
        Default text classifier/regressor for use as a learner
        when only covariate/confounder is a text field.
        If `is_classifier=True`, a LogisticRegression model will be used.
        If `is_classifier=False`, a LinearRegression model will be used.
        """
        self.is_classifier = is_classifier
        self.model = None


    def create_model(self, texts):
        """
        create a model
        Args:
          texts(list): list of texts
        """
        token_pattern = r'\w+|[%s]' % string.punctuation
        if self.is_classifier:
            clf = LogisticRegression()
        else:
            clf = LinearRegression()

        self.model = Pipeline([ ('vect', CountVectorizer()),
                                ('tfidf', TfidfTransformer()),
                                ('clf', clf) ])
        return


    def fit(self, x_train, y_train):
        """
        train a classifier
        Args:
          x_train(list or np.ndarray):  training texts
          y_train(np.ndarray):  training labels
        """
        if self.model is None:
            self.create_model(x_train)
        self.model.fit(x_train, y_train)


    def predict(self, x_test, return_proba=False):
        """
        make predictions on text data
        Args:
          x_test(list or np.ndarray or str): array of texts on which to make predictions
          or a string representing text
        """
        if return_proba and not hasattr(self.model['clf'], 'predict_proba'):
            raise ValueError('%s does not support predict_proba' % (type(self.model['clf']).__name__))
        if isinstance(x_test, str): x_test = [x_test]
        if self.model is None: raise ValueError('model is None - call fit or load to set the model')
        if return_proba:
            predicted = self.model.predict_proba(x_test)
        else:
            predicted = self.model.predict(x_test)
        if len(predicted) == 1: predicted = predicted[0]
        return predicted


    def predict_proba(self, x_test):
        """
        predict_proba returns the prediction probabilities for texts in  `x_test`
        """
        return self.predict(x_test, return_proba=True)


    def evaluate(self, x_test, y_test):
        """
        evaluate
        Args:
          x_test(list or np.ndarray):  training texts
          y_test(np.ndarray):  training labels
        """
        predicted = self.predict(x_test)
        return np.mean(predicted == y_test)


    def save(self, filename):
        """
        save model
        """
        dump(self.model, filename)


    def load(self, filename):
        """
        load model
        """
        self.model = load(filename)


